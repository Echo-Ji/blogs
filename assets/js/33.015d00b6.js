(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{306:function(s,t,a){"use strict";a.r(t);var e=a(5),i=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"基于距离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于距离"}},[s._v("#")]),s._v(" 基于距离")]),s._v(" "),a("p",[s._v("K-means 是基于距离的聚类方法的代表，这类方法的聚类结果都是球状的簇，当数据中存在非球状结构时，其效果并不好。")]),s._v(" "),a("h3",{attrs:{id:"k-means-适用条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#k-means-适用条件"}},[s._v("#")]),s._v(" K-means 适用条件")]),s._v(" "),a("p",[s._v("但 K-means 算法简单有效，其适用条件为：")]),s._v(" "),a("ul",[a("li",[s._v("空间中存在距离度量 "),a("code",[s._v("<a, b>")]),s._v("，且满足 "),a("code",[s._v("<a, b> = <b, a>")])]),s._v(" "),a("li",[s._v("存在求中心点的算法")])]),s._v(" "),a("p",[s._v("比如瑞士卷图就不满足这样的条件，因此不适合使用 K-means 算法。")]),s._v(" "),a("h3",{attrs:{id:"k-means-改进算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#k-means-改进算法"}},[s._v("#")]),s._v(" K-means 改进算法")]),s._v(" "),a("p",[s._v("针对 K-means 算法有很多改进，比如 优化初始化类中心的 K-means ++，动态调整类个数的 ISODATA，避免陷入局部最优的二分 K-means，解决海量数据聚类的 Mini-Batch K-means 等。")]),s._v(" "),a("p",[s._v("这里简单说一下 K-means ++。该算法改进了 K-means 算法的初始化类中心的过程，使得一开始的类中心能够尽可能地分散。具体方法是：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("计算每一个样本点 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[s._v("x")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("x")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.43056em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit"},[s._v("x")])])])]),s._v(" 到已有的类中心的最短距离 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mi",[s._v("D")]),a("mo",[s._v("(")]),a("mi",[s._v("x")]),a("mo",[s._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("D(x)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[s._v("D")]),a("span",{staticClass:"mopen"},[s._v("(")]),a("span",{staticClass:"mord mathit"},[s._v("x")]),a("span",{staticClass:"mclose"},[s._v(")")])])])])])]),s._v(" "),a("li",[a("p",[s._v("计算每个样本点被选为下一个类中心的概率 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",[a("semantics",[a("mrow",[a("mfrac",[a("mrow",[a("mi",[s._v("D")]),a("mo",[s._v("(")]),a("mi",[s._v("x")]),a("msup",[a("mo",[s._v(")")]),a("mn",[s._v("2")])],1)],1),a("mrow",[a("msub",[a("mo",[s._v("∑")]),a("mrow",[a("mi",[s._v("x")]),a("mo",[s._v("∈")]),a("mi",[s._v("X")])],1)],1),a("mi",[s._v("D")]),a("mo",[s._v("(")]),a("mi",[s._v("x")]),a("msup",[a("mo",[s._v(")")]),a("mn",[s._v("2")])],1)],1)],1)],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("\\frac{D(x)^2}{\\sum_{x \\in X} D(x)^2}")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"strut",staticStyle:{height:"1.06132em"}}),a("span",{staticClass:"strut bottom",staticStyle:{height:"1.635877em","vertical-align":"-0.574557em"}}),a("span",{staticClass:"base textstyle uncramped"},[a("span",{staticClass:"mord reset-textstyle textstyle uncramped"},[a("span",{staticClass:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"}),a("span",{staticClass:"mfrac"},[a("span",{staticClass:"vlist"},[a("span",{staticStyle:{top:"0.345em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-textstyle scriptstyle cramped"},[a("span",{staticClass:"mord scriptstyle cramped"},[a("span",{staticClass:"mop"},[a("span",{staticClass:"op-symbol small-op mop",staticStyle:{top:"0.074995em"}},[s._v("∑")]),a("span",{staticClass:"vlist"},[a("span",{staticStyle:{top:"0.30001em","margin-right":"0.07142857142857144em","margin-left":"0em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-scriptstyle scriptscriptstyle cramped"},[a("span",{staticClass:"mord scriptscriptstyle cramped"},[a("span",{staticClass:"mord mathit"},[s._v("x")]),a("span",{staticClass:"mrel"},[s._v("∈")]),a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.07847em"}},[s._v("X")])])])]),a("span",{staticClass:"baseline-fix"},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),s._v("​")])])]),a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[s._v("D")]),a("span",{staticClass:"mopen"},[s._v("(")]),a("span",{staticClass:"mord mathit"},[s._v("x")]),a("span",{staticClass:"mclose"},[a("span",{staticClass:"mclose"},[s._v(")")]),a("span",{staticClass:"vlist"},[a("span",{staticStyle:{top:"-0.289em","margin-right":"0.07142857142857144em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-scriptstyle scriptscriptstyle cramped"},[a("span",{staticClass:"mord mathrm"},[s._v("2")])])]),a("span",{staticClass:"baseline-fix"},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),s._v("​")])])])])])]),a("span",{staticStyle:{top:"-0.22999999999999998em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-textstyle textstyle uncramped frac-line"})]),a("span",{staticStyle:{top:"-0.485em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-textstyle scriptstyle uncramped"},[a("span",{staticClass:"mord scriptstyle uncramped"},[a("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.02778em"}},[s._v("D")]),a("span",{staticClass:"mopen"},[s._v("(")]),a("span",{staticClass:"mord mathit"},[s._v("x")]),a("span",{staticClass:"mclose"},[a("span",{staticClass:"mclose"},[s._v(")")]),a("span",{staticClass:"vlist"},[a("span",{staticStyle:{top:"-0.363em","margin-right":"0.07142857142857144em"}},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),a("span",{staticClass:"reset-scriptstyle scriptscriptstyle uncramped"},[a("span",{staticClass:"mord mathrm"},[s._v("2")])])]),a("span",{staticClass:"baseline-fix"},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),s._v("​")])])])])])]),a("span",{staticClass:"baseline-fix"},[a("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[a("span",{staticStyle:{"font-size":"0em"}},[s._v("​")])]),s._v("​")])])]),a("span",{staticClass:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"})])])])])])]),s._v(" "),a("li",[a("p",[s._v("按样本顺序求概率累加和，按照轮盘法选择出下一个类中心")])])]),s._v(" "),a("h2",{attrs:{id:"基于密度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于密度"}},[s._v("#")]),s._v(" 基于密度")]),s._v(" "),a("p",[s._v("与基于距离的聚类算法不同的是，基于密度的聚类算法可以发现任意形状的聚类，DBSCAN 便是这类方法的一个代表。")]),s._v(" "),a("h3",{attrs:{id:"dbscan-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dbscan-算法"}},[s._v("#")]),s._v(" DBSCAN 算法")]),s._v(" "),a("p",[s._v("DBSCAN 算法的基本思想是寻找被低密度区域分离的高密度区域，作为一个“簇”。其中“簇”的定义为：由密度可达关系导出的最大密度相连样本的集合。")]),s._v(" "),a("h3",{attrs:{id:"dbscan-与-k-means-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dbscan-与-k-means-对比"}},[s._v("#")]),s._v(" DBSCAN 与 K-means 对比")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th"),s._v(" "),a("th",[s._v("K-means")]),s._v(" "),a("th",[s._v("DBSCAN")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("数据集")]),s._v(" "),a("td",[s._v("只适用于凸样本集，聚类结果为球状簇")]),s._v(" "),a("td",[s._v("对样本集无要求，可以发现任意形状的簇，但当聚类密度不均匀时，聚类质量较差")])]),s._v(" "),a("tr",[a("td",[s._v("初始化")]),s._v(" "),a("td",[s._v("需要预先声明聚类个数，且初始值对结果影响较大")]),s._v(" "),a("td",[s._v("不需要预先声明聚类个数，聚类结果没有偏倚")])]),s._v(" "),a("tr",[a("td",[s._v("异常值")]),s._v(" "),a("td",[s._v("对异常值较为敏感")]),s._v(" "),a("td",[s._v("对异常值不敏感")])]),s._v(" "),a("tr",[a("td",[s._v("海量数据")]),s._v(" "),a("td",[s._v("考虑 mini-batch K-means")]),s._v(" "),a("td",[s._v("建立 KD 树搜索最近邻")])])])]),s._v(" "),a("h2",{attrs:{id:"谱聚类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谱聚类"}},[s._v("#")]),s._v(" 谱聚类")]),s._v(" "),a("p",[s._v("谱聚类是广泛使用的聚类算法，比起传统的 K-means，谱聚类对数据分布的适应性更强，聚类效果也更优秀，同时计算量也小很多，实现起来也不复杂。")]),s._v(" "),a("p",[s._v("谱聚类的思想是将原始样本点看作图中的节点，用顶点间的相似度度量作为边的权重，构造相似度矩阵，从而将聚类问题转化为图划分问题。而基于图论的最优划分准则就是使划分得到的子图内部相似度最大，子图之间相似度最小。")]),s._v(" "),a("p",[s._v("其实说白了就是构建相似矩阵，子图划分（用 Laplace 矩阵求解特征向量），聚类划分数据簇，而这三部分别最常用的是基于高斯核的全连接方式，基于权重的 Ncut 切图以及 K-means 聚类。")]),s._v(" "),a("p",[s._v("但是谱聚类非常依赖于相似矩阵的构建，因此不同的距离度量对最终的聚类效果影响很大。")]),s._v(" "),a("p",[s._v("参考 "),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29849122",target:"_blank",rel:"noopener noreferrer"}},[s._v("1"),a("OutboundLink")],1),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"模型聚类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模型聚类"}},[s._v("#")]),s._v(" 模型聚类")]),s._v(" "),a("p",[s._v("代表为 GMM 模型，它是一个生成模型，该模型试图找到多为高斯模型概率分布的混合表示，从而拟合出任意形状的分布。")]),s._v(" "),a("p",[s._v("它使用 EM 算法进行迭代，而且给出的聚类结果是软聚类，即每一个样本只给出属于每一类的概率，同时在模型运行结束后，还可以用于生成新的样本。这些特性使得 GMM 在风控领域非常受欢迎。")]),s._v(" "),a("h2",{attrs:{id:"层次聚类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#层次聚类"}},[s._v("#")]),s._v(" 层次聚类")]),s._v(" "),a("p",[s._v("层次聚类分为自顶向下和自底向上两种方式，也叫分裂和凝聚。自顶向下是将单个连通网络不断划分，直到每个分支只有单个节点为止，自底向上则相反。")]),s._v(" "),a("p",[s._v("其分裂（凝聚）依据的差异产生了不同的算法，层次分裂的代表是用于社区发现的 GN 算法，而层次凝聚的代表是 AGNES 算法。")]),s._v(" "),a("p",[s._v("可以看到，层次聚类的局限之处在于较高的时间复杂度，因为每更新一步，所有的簇都需要重新计算度量。")]),s._v(" "),a("p",[s._v("最后，附上一张各种聚类的效果图 👏。")]),s._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{margin:"0 auto"},attrs:{src:s.$withBase("/2020-09-07-cluster.jpeg"),alt:"2020-09-07-clst"}})])])}),[],!1,null,null,null);t.default=i.exports}}]);