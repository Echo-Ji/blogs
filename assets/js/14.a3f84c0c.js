(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{285:function(t,s,a){"use strict";a.r(s);var n=a(5),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("C++ 是一个难学易用的语言！难学一方面在于其广博，因此我选择用笔记的形式精简出一些有用的条款。")])]),t._v(" "),a("h2",{attrs:{id:"数组与多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组与多态"}},[t._v("#")]),t._v(" 数组与多态")]),t._v(" "),a("ol",[a("li",[t._v("多态和指针算法不能混合在一起，因此不要对数组使用多态")]),t._v(" "),a("li",[t._v("尽量不要从具体类（concrete classes）派生具体类")])]),t._v(" "),a("p",[t._v("数组的静态分配与动态分配：")]),t._v(" "),a("ol",[a("li",[t._v("静态分配：在栈中分配内存，作用于局部，不能用作函数返回值")]),t._v(" "),a("li",[t._v("动态分配：需要关键字 "),a("code",[t._v("new")]),t._v(" 在堆中分配内存，使用完后要 "),a("code",[t._v("delete")]),t._v("，一般用数组首地址来寻址数组，即数组指针")])]),t._v(" "),a("h2",{attrs:{id:"缺省构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺省构造函数"}},[t._v("#")]),t._v(" 缺省构造函数")]),t._v(" "),a("p",[t._v("避免"),a("strong",[t._v("无用")]),t._v("的缺省构造函数，因为他会使得大多数成员函数都得检测异常，从而浪费计算资源，降低效率。")]),t._v(" "),a("h2",{attrs:{id:"运算符重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载"}},[t._v("#")]),t._v(" 运算符重载")]),t._v(" "),a("p",[t._v("谨慎定义类型转换函数，注意，单参数构造函数和隐式类型转换操作符（"),a("code",[t._v("operator")]),t._v("修饰）会允许编译器进行隐式类型转换。")]),t._v(" "),a("p",[t._v("隐式类型转换举例，定义一个成员函数为：")]),t._v(" "),a("div",{staticClass:"language-C ++ line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("class Rational"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\npublic"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    operator "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数声明尾加const说明这个函数不可以修改类的成员变量")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("消除方法：")]),t._v(" "),a("ol",[a("li",[t._v("将隐式类型转换操作符转换为显式调用的函数。")]),t._v(" "),a("li",[t._v("给单参数构造函数添加 "),a("code",[t._v("explicit")]),t._v(" 关键字，或者，用 proxy classes 来代替单参数构造函数的参数类型")])]),t._v(" "),a("p",[t._v("虽然存在消除方法，但是除非万不得已，不要定义类型转换函数。")])])}),[],!1,null,null,null);s.default=e.exports}}]);