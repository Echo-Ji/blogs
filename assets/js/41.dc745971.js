(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{311:function(t,e,_){"use strict";_.r(e);var v=_(5),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("谈起计算机网络，不得不祭出这张图。")]),t._v(" "),_("div",{staticStyle:{"text-align":"center"}},[_("img",{staticStyle:{margin:"0 auto"},attrs:{src:t.$withBase("/2020-09-20-OSI-TCPIP.gif"),",":"",alt:"2020-09-20-OSI-TCPIP",",":""}})]),t._v(" "),_("h2",{attrs:{id:"_1-当浏览器输入一个url请求会经历什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-当浏览器输入一个url请求会经历什么？"}},[t._v("#")]),t._v(" 1. 当浏览器输入一个url请求会经历什么？")]),t._v(" "),_("p",[t._v("主要流程大致如下：")]),t._v(" "),_("ul",[_("li",[t._v("DNS 域名解析")]),t._v(" "),_("li",[t._v("建立 TCP 连接（三次握手）")]),t._v(" "),_("li",[t._v("发起 HTTP 请求（Request）")]),t._v(" "),_("li",[t._v("服务器处理请求，浏览器接受 HTTP 响应（Response）")]),t._v(" "),_("li",[t._v("浏览器解析渲染页面")]),t._v(" "),_("li",[t._v("连接结束（四次挥手）\n下面解释下各部分。")])]),t._v(" "),_("p",[t._v("贴一张画的很全面的图（来自https://juejin.im/post/6864175613209640973，侵删）。")]),t._v(" "),_("div",{staticStyle:{"text-align":"center"}},[_("img",{staticStyle:{margin:"0 auto"},attrs:{src:t.$withBase("/2020-09-20-url.png"),alt:"2020-09-20-url"}})]),t._v(" "),_("h3",{attrs:{id:"_1-1-dns-域名解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-dns-域名解析"}},[t._v("#")]),t._v(" 1.1 DNS 域名解析")]),t._v(" "),_("p",[t._v("浏览器 DNS 缓存 -> 本地 hosts 文件 -> 本地 DNS 解析器缓存 -> 本地 DNS 服务器（具有权威性）-> 非本地 DNS 服务器区域有缓存（不具有权威性）-> 本地 DNS 服务器迭代查询（根、二级、三级...），查询到之后，先缓存再返回给客户机。")]),t._v(" "),_("h3",{attrs:{id:"_1-2-三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-三次握手"}},[t._v("#")]),t._v(" 1.2 三次握手")]),t._v(" "),_("p",[t._v("发送端 SYN = 1, seq = x -> 接收端 SYN = 1, ACK = 1, seq = y, ack= x + 1 -> 发送端 ACK = 1, seq = x + 1, ack = y + 1。")]),t._v(" "),_("blockquote",[_("p",[t._v("为什么TCP客户端最后还要发送一次确认呢？")])]),t._v(" "),_("p",[t._v("主要是为了防止已经失效的连接请求报文突然又传到服务器，产生错误和资源浪费。")]),t._v(" "),_("h3",{attrs:{id:"_1-3-发起-http-请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-发起-http-请求"}},[t._v("#")]),t._v(" 1.3 发起 HTTP 请求")]),t._v(" "),_("p",[t._v("完整的 HTTP 请求包括起始行、请求头部、请求主体三部分。\n请求方法有：")]),t._v(" "),_("ul",[_("li",[t._v("GET：获取资源")]),t._v(" "),_("li",[t._v("POST：传输实体主体")]),t._v(" "),_("li",[t._v("PUT：传输文件")]),t._v(" "),_("li",[t._v("DELETE：删除文件")]),t._v(" "),_("li",[t._v("HEAD：获取报文首部")]),t._v(" "),_("li",[t._v("OPTIONS：询问支持的方法")]),t._v(" "),_("li",[t._v("TRACE：追踪路径")])]),t._v(" "),_("p",[t._v("GET 和 POST 的区别：")]),t._v(" "),_("ul",[_("li",[t._v("GET 请求没有 body，只有 url，请求数据放在 url 的 querystring 中；POST 请求的数据在 body 中，通常来自于表单提交。")]),t._v(" "),_("li",[t._v("所以，GET 请求对访问数据没有副作用，POST 有副作用，就好比数据库中的查询和更新。")]),t._v(" "),_("li",[t._v("因此，GET 可以被缓存，而 POST 不能缓存，也不能被收藏为书签。")])]),t._v(" "),_("h3",{attrs:{id:"_1-4-接收-http-响应"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-接收-http-响应"}},[t._v("#")]),t._v(" 1.4 接收 HTTP 响应")]),t._v(" "),_("p",[t._v("服务器受到浏览器发送的 HTTP 请求后，会将 HTTP 报文封装成 HTTP 的 Request 对象，并通过不同的 Web 服务器进行处理，处理完的结果以 HTTP 的 Response 对象返回，主要包括状态码，响应头和响应报文三部分。")]),t._v(" "),_("p",[t._v("⚠️ 注意，"),_("strong",[t._v("TCP 规定")]),t._v("，")]),t._v(" "),_("ul",[_("li",[t._v("SYN 报文段不能携带数据，但要消耗一个序号")]),t._v(" "),_("li",[t._v("ACK 报文可以携带数据，但如果不携带数据则不消耗序号")]),t._v(" "),_("li",[t._v("FIN 报文段可以携带数据，但即使不携带数据也要消耗一个序号。")])]),t._v(" "),_("blockquote",[_("p",[t._v("为什么建立连接时三次握手而关闭连接要四次握手？")])]),t._v(" "),_("p",[t._v("建立连接的时候，服务器在 LISTEN 状态下，收到建立连接请求的 SYN 的报文后，把 ACK 和 SYN 放在同一个报文段里发送给客户端。\n而关闭连接的时候，服务器收到对方的 FIN 报文段，只是表示对方不再发送数据了但还能接收数据，此时服务器也未必已经发送完所有的数据了，因此服务器可以立即关闭，也可以发送完剩下的数据后再发送 FIN 报文段表示同意关闭连接，所以服务器的 ACK 和 FIN 一般都会分开发送，导致多了一次挥手。")]),t._v(" "),_("blockquote",[_("p",[t._v("如果已经建立了连接，但客户端故障了怎么办？")])]),t._v(" "),_("p",[t._v("服务器设置了一个保活计时器来避免资源浪费，一般是 2 个小时，如果连接建立后一直没有收到客户端的数据，那么在保活计时器超时之后，服务器就会发送一个探测报文，以后每隔 75 分钟发送一个，若一连 10 个探测报文都没有回应，则服务器认为客户端故障，主动关闭连接。")]),t._v(" "),_("h3",{attrs:{id:"_1-5-浏览器解析渲染页面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-浏览器解析渲染页面"}},[t._v("#")]),t._v(" 1.5 浏览器解析渲染页面")]),t._v(" "),_("ul",[_("li",[t._v("构建文档对象模型（DOM）")]),t._v(" "),_("li",[t._v("构建 CSS 对象模型（CSSOM）")]),t._v(" "),_("li",[t._v("构建渲染树（Render Tree）")]),t._v(" "),_("li",[t._v("布局")]),t._v(" "),_("li",[t._v("绘制")])]),t._v(" "),_("h3",{attrs:{id:"_1-6-关闭连接（四次挥手）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-关闭连接（四次挥手）"}},[t._v("#")]),t._v(" 1.6 关闭连接（四次挥手）")]),t._v(" "),_("p",[t._v("浏览器发完数据后，发送 FIN 请求断开连接 -> 服务器发送 ACK 表示同意 -> 服务器发送 FIN 请求断开连接 -> 浏览器发送 ACK 表示同意。")]),t._v(" "),_("h2",{attrs:{id:"_2-dns-服务器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-dns-服务器"}},[t._v("#")]),t._v(" 2. DNS 服务器")]),t._v(" "),_("p",[t._v("DNS 服务器分为三类：根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。")]),t._v(" "),_("p",[t._v("DSN 查询有递归查询和迭代查询，其区别如下：")]),t._v(" "),_("ul",[_("li",[t._v("递归查询：必须返回一个准确的查询结果，如果该 DNS 服务器没有查到，那么就会成为代理去询问其他服务器。")]),t._v(" "),_("li",[t._v("迭代查询：DNS 服务器会像请求端返回其他能够解释查询的 DNS 服务器。")])]),t._v(" "),_("p",[t._v("一般情况下，从请求主机到本地 DNS 服务器的查询是递归的，其余查询是迭代的。")]),t._v(" "),_("h2",{attrs:{id:"_3-tcp-与-udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp-与-udp"}},[t._v("#")]),t._v(" 3. TCP 与 UDP")]),t._v(" "),_("h3",{attrs:{id:"_3-1-优劣对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-优劣对比"}},[t._v("#")]),t._v(" 3.1 优劣对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}}),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("TCP")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("UDP")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("连接状态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("面向连接")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("无连接")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("可靠性")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("可靠交付")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("尽最大努力交付")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("实时性")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("效率比 UDP 低")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("实时性好")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("收发方")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("点对点")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("一对一/多，多对一/多都可")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("系统资源需求")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("较高")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("较少")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("备注")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("TCP 通过流量控制、序号、确认和定时器，确保正确、按序将数据从发送进程交付给接收进程")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("适用于对高速传输和实时性要求较高的通信或广播通信，且对数据安全性无特殊要求")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-2-tcp-发送方"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-tcp-发送方"}},[t._v("#")]),t._v(" 3.2 TCP 发送方")]),t._v(" "),_("p",[t._v("超时重传，快重传。")]),t._v(" "),_("p",[t._v("快重传：在某报文段的定时器过期之前重传丢失的报文段。")]),t._v(" "),_("h3",{attrs:{id:"_3-3-tcp-接收方"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-tcp-接收方"}},[t._v("#")]),t._v(" 3.3 TCP 接收方")]),t._v(" "),_("p",[t._v("累计确认，差错恢复。")]),t._v(" "),_("p",[t._v("虽然 TCP 是累计确认（类似 Go-Back-N，GBN 协议），但是它会缓存失序报文段，且允许接收方有选择地确认失序报文段，这就使得发送方可以选择重传（类似 Select-Repeat，SR 协议）。\n因此，TCP 的差错恢复机制为 GBN 协议和 SR 协议的混合体。")]),t._v(" "),_("h3",{attrs:{id:"_3-4-tcp-流量控制与拥塞控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-tcp-流量控制与拥塞控制"}},[t._v("#")]),t._v(" 3.4 TCP 流量控制与拥塞控制")]),t._v(" "),_("p",[t._v("都是对发送方的遏制。")]),t._v(" "),_("p",[t._v("流量控制是流量控制也是一个速率匹配服务，是为了避免接收方缓存溢出的。它其实是一个速率匹配服务，让发送方发送但未被确认的数据量小于接收方的接收窗口大小（rwnd 是动态变化的），就可以保证接收方缓存不会溢出。")]),t._v(" "),_("p",[t._v("拥塞控制是一个全局性的过程，为了避免过多数据注入到网络中，保证路由器或链路不过载的。拥塞的标志可以说是重传计时器超时或接收到三个重复确认。相关算法有慢启动算法、拥塞避免算法（使网络比较不容易拥塞而不是完全避免）、快重传、快恢复。")]),t._v(" "),_("h2",{attrs:{id:"_4-http-协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-http-协议"}},[t._v("#")]),t._v(" 4. HTTP 协议")]),t._v(" "),_("p",[t._v("HTTP 协议包括两种报文：请求（Request）报文和响应（Response）报文，"),_("a",{attrs:{href:"https://juejin.im/post/6864175613209640973#heading-23",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),_("OutboundLink")],1),t._v("有很详细的解释。")]),t._v(" "),_("p",[t._v("https://juejin.im/post/6864175613209640973#heading-26")]),t._v(" "),_("h2",{attrs:{id:"_5-cookie-和-session"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-cookie-和-session"}},[t._v("#")]),t._v(" 5. Cookie 和 Session")]),t._v(" "),_("p",[t._v("Cookie 和 Session 是用户识别和状态管理的机制，都是会话技术。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}}),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("Cookie")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("Session")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("运行")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("在客户端（浏览器）")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("在服务器")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("限制")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("大小4K，且个数也有限制")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("与服务器内存相关")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("备注")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("有安全隐患，通过拦截或本地文件找到你的 Cookie 后可以进行攻击")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Session 保存在服务器上一段时间后才会消失，如果 Session 过多会增加服务器的压力")])])])]),t._v(" "),_("h3",{attrs:{id:"_5-1-同域验证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-同域验证"}},[t._v("#")]),t._v(" 5.1 同域验证")]),t._v(" "),_("p",[t._v("由于 HTTP 是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这是哪个用户发过来的了，因而需要状态管理，以便服务器知道 HTTP 请求的发起者，从而判断该用户是否有权限继续这个请求，这个过程就是会话管理。")]),t._v(" "),_("p",[t._v("如果前端，后台 API 部署在同域下，登录方式相对简单，有以下两种：")]),t._v(" "),_("ul",[_("li",[t._v("基于 Session 登录：用 Cookie（在 HTTP header 中） 存储 Sessionid，在服务器 Session 中判断是否有登录凭证。")]),t._v(" "),_("li",[t._v("基于 Token 登录：用 Token（放到 URL 参数或 HTTP header 中） 去服务器解密并检查其内部的登录凭证是否有效。")])]),t._v(" "),_("h3",{attrs:{id:"_5-2-跨域验证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-跨域验证"}},[t._v("#")]),t._v(" 5.2 跨域验证")]),t._v(" "),_("p",[t._v("浏览器具有同源策略，凡是发送请求的 URL、域名、端口号有一个与当前页面不同则视为跨域。")]),t._v(" "),_("p",[t._v("而浏览器不能跨域读取 Cookie 信息，因此，当客户端跨域访问时，浏览器"),_("strong",[t._v("不能")]),t._v("读取先前"),_("strong",[t._v("跨域的服务器")]),t._v("返回的 Cookie 信息，而服务器检测不到客户端请求里的会话信息，就"),_("strong",[t._v("判断客户端没有登录")]),t._v("！")]),t._v(" "),_("p",[t._v("需要两步"),_("a",{attrs:{href:"https://www.cnblogs.com/Jaffray/p/11626664.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("解决跨域问题"),_("OutboundLink")],1),t._v("：")]),t._v(" "),_("ul",[_("li",[t._v("解决同源问题：在服务器设置 "),_("code",[t._v("Access-Control-Allow-Header")]),t._v("、"),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 为星号，若要发送 Cookie，则 "),_("code",[t._v("Origin")]),t._v(" 不能设置星号，需要设置为明确的、与客户端一致的域名。")]),t._v(" "),_("li",[t._v("请求带上 Cookie 信息：CORS 默认不发送 Cookie 和 HTTP 认证信息，因此服务器需要指定 "),_("code",[t._v("Access-Control-Allow-Credentials: true")]),t._v("，另一方面需要在客户端的请求中添加 "),_("code",[t._v("withCredentials")]),t._v(" 属性。")])]),t._v(" "),_("h2",{attrs:{id:"_6-http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-http"}},[t._v("#")]),t._v(" 6. HTTP")]),t._v(" "),_("p",[t._v("影响 HTTP 网络请求的因素主要有两个：带宽和延迟。")]),t._v(" "),_("p",[t._v("HTTP1.0 与 HTTP1.1 的区别（对缓断续错享长）")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}}),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("HTTP1.0")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("HTTP1.1")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("缓存处理")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("强制缓存")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("对比缓存")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("带宽优化和网络连接的使用")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("需 Part 给 ALL")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("支持断点续传")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("错误通知管理")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("xx")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("新增 24 个错误状态响应码")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("Host 头处理")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("xx")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("虚拟主机共享 IP")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("长连接")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("每次请求都要三次握手")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("持久化连接和管线化处理")])])])]),t._v(" "),_("p",[t._v("把添加了加密、认证机制、完整性保护的 HTTP 称为 HTTPS。")]),t._v(" "),_("p",[t._v("关于 HTTPS 的解释，个人认为"),_("a",{attrs:{href:"https://juejin.im/post/6844903608421449742",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),_("OutboundLink")],1),t._v("讲的比较通俗。")]),t._v(" "),_("h2",{attrs:{id:"_7-websocket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-websocket"}},[t._v("#")]),t._v(" 7. WebSocket")]),t._v(" "),_("p",[t._v("HTML5 开始提供的一个全双工通信协议，建立连接时由客户端请求 HTTP 协议升级，握手成功后，使用 WebSocket 协议进行通信。")]),t._v(" "),_("p",[t._v("WebSocket 采用心跳来确保 TCP 通道保持连接没有断开（ping[0x9]、pong[0xA]）。")])])}),[],!1,null,null,null);e.default=a.exports}}]);