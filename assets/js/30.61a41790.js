(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{300:function(s,t,a){"use strict";a.r(t);var n=a(5),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。")])]),s._v(" "),a("h3",{attrs:{id:"回溯算法的要素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法的要素"}},[s._v("#")]),s._v(" 回溯算法的要素")]),s._v(" "),a("p",[s._v("回溯算法跟动态规划算法有些类似，动态规划里强调的是"),a("strong",[s._v("状态")]),s._v("，"),a("strong",[s._v("选择")]),s._v("和 "),a("strong",[s._v("base case")]),s._v("，而回溯法里强调的是"),a("strong",[s._v("路径")]),s._v("，"),a("strong",[s._v("选择列表")]),s._v("和"),a("strong",[s._v("结束条件")]),s._v("。")]),s._v(" "),a("p",[s._v("解决一个回溯问题，其实就是一个决策树的遍历过程，只需考虑以下三个问题：")]),s._v(" "),a("ul",[a("li",[s._v("路径：也就是已经做出的选择")]),s._v(" "),a("li",[s._v("选择列表：即当下可以做的选择")]),s._v(" "),a("li",[s._v("结束条件：到达决策树底层，无法再做选择的条件")])]),s._v(" "),a("h3",{attrs:{id:"回溯算法框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法框架"}},[s._v("#")]),s._v(" 回溯算法框架")]),s._v(" "),a("div",{staticClass:"language-Python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[s._v("result "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("def")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("backtrace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("选择列表"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" 路径"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" 满足结束条件"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("add"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("路径"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" 选择 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" 选择列表"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        做选择\n        backtrace"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("选择列表，路径"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        撤销选择\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("其核心就是 "),a("code",[s._v("for")]),s._v(" 循环里的递归，在递归前做选择，递归后撤销选择。")]),s._v(" "),a("h3",{attrs:{id:"应用例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用例子"}},[s._v("#")]),s._v(" 应用例子")]),s._v(" "),a("p",[s._v("全排列、八皇后问题都是很经典的回溯问题，此外，当遇到二维数组、网格移动等问题也可以考虑使用回溯法。")])])}),[],!1,null,null,null);t.default=r.exports}}]);