(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{288:function(v,_,t){"use strict";t.r(_);var e=t(5),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("C++ 是一个难学易用的语言！难学一方面在于其广博，因此我选择用笔记的形式精简出一些有用的条款。")])]),v._v(" "),t("h2",{attrs:{id:"函数与异常的参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数与异常的参数"}},[v._v("#")]),v._v(" 函数与异常的参数")]),v._v(" "),t("p",[v._v("虽然函数的参数声明与 "),t("code",[v._v("catch")]),v._v(" 子句中声明参数看起来几乎没什么区别，但其实存在这巨大的差异。")]),v._v(" "),t("ol",[t("li",[v._v("调用函数时，程序的控制权会回到函数调用处；但抛出异常时，控制权永远不会回到抛出异常的地方")]),v._v(" "),t("li",[v._v("对象作为参数传递给函数时不一定需要拷贝；但异常对象在传递时总是进行拷贝构造，当通过传值方式捕获时，异常对象被拷贝了两次，一个是所有异常都必须建立的临时对象，另一个则是传值方式决定的拷贝")]),v._v(" "),t("li",[v._v("对象作为参数传递给函数与作为异常被抛出相比，前者类型转换比后者多，后者只有两种形式：继承类与基类，类型化指针（typed pointer）与无类型指针（untyped pointer）")]),v._v(" "),t("li",[t("code",[v._v("catch")]),v._v(" 子句进行异常匹配的顺序是他们在源代码中出现的顺序，而一个对象调用虚函数时，总选择最佳匹配的类，与源代码顺序无关")])]),v._v(" "),t("p",[v._v("注意，")]),v._v(" "),t("p",[v._v("用 "),t("code",[v._v("throw")]),v._v(" 总是抛出当前的异常，即不改变传递出去的异常类型，不用生成一个新拷贝。")]),v._v(" "),t("p",[v._v("而"),t("code",[v._v("throw obj")]),v._v(" 会拷贝构造一个新异常，且拷贝构造时使用静态类型，通常会改变异常的类型（从继承类变为基类）。")]),v._v(" "),t("h2",{attrs:{id:"要通过引用捕获异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#要通过引用捕获异常"}},[v._v("#")]),v._v(" 要通过引用捕获异常")]),v._v(" "),t("p",[v._v("用过引用捕获异常，可以避免以下问题")]),v._v(" "),t("ol",[t("li",[v._v("不会为是否删除异常对象而烦恼（传指针）")]),v._v(" "),t("li",[v._v("能够避开 slicing 异常对象（传值）")]),v._v(" "),t("li",[v._v("能够捕获标准异常类型（传指针）")]),v._v(" "),t("li",[v._v("减少异常对象被拷贝的次数（传值，两次）")])]),v._v(" "),t("p",[v._v("所以，尽量要通过引用捕获异常！")])])}),[],!1,null,null,null);_.default=o.exports}}]);